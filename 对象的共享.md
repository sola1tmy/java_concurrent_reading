# 对象的共享

### 失效数据
- 读取前数据已经被修改（失效）
- 最低安全性：可能是一个失效值，但至少是其他线程设置的值
- 大多数变量符合最低安全性，除了非volatile的64位数值变量（double，long）
- 加锁不仅限于互斥行为，还包括内存可见性

### 发布与逸出
- 发布：能够在当前域之外的代码中使用
    - 发布内部状态会破坏封装性
    - 构造完成之前发布会破坏线程安全性 

### 线程封闭
- 一项数据只在单线程中被使用，称为线程封闭
- Ad-hoc线程封闭是指维护线程封闭性的职责完全由程序来承担
    - 如果只有单个线程进行写操作，那么用volatile就够了

#### 栈封闭
- 在栈封闭中（方法），只能通过局部变量才能访问对象
    - 在修改代码过程中，可能会有玩家提取数据，破坏了栈封闭

#### ThreadLocal
- ThreadLocal能将数据和线程绑定起来

### 不变性
- 不可变对象是线程安全的
- 不可变对象条件
    - 对象正确构建
    - 对象创建以后其状态不能修改
    - 所有域都是final的

### 安全发布
#### 安全发布的常用模式
- 四种模式
    - 在静态初始化函数中初始化一个对象引用
    - 将对象的引用保存到volatile类型或者atomicReference中
    - 将对象的引用保存到某个正确构造对象的final类型域中
    - 将对象的引用保存到一个由锁保护的域中
- 静态初始化器在JVM初始化阶段执行，JVM的同步机制，保证这种初始化能安全的发布

### 事实不可变对象
- 可变，但是没有任何地方去进行修改，**安全发布后**可以当做不可变对象发布

### 可变对象
- 需要volatile，原子性，同步来保证安全发布

###summary
- 不可变对象可以通过任何机制来发布
- 事实不可变对象必须通过安全发布来发布
- 可变对象必须通过安全方式来发布，并且必须是线程安全或者由某个锁来保护
- 使用和共享对象的策略
    - 线程封闭
    - 只读共享
    - 线程安全共享
    - 保护对象

### 奇奇怪怪的知识点
- 重排序将数据放到寄存器，在很多情况下可以有更高效的速度
- final能保证初始化的安全性，从而可以不受限制地访问不可变对象，并在共享时无需同步

### 注意
- 通常，我们无法确保执行读操作的线程能够适时看到其他线程写入的值
- 重排序可能影响到线程里（p28的例子）
- 64位的变量会被分解成2个32位的操作，所以多线程。。
- volatile使用的
    - 对变量的写入操作不依赖变量当前之，或者你能确保只有单个线程更新变量的值
    - 该变量不会与其他状态变量一起纳入不变性条件中
    - 在访问变量时不需要加锁
- Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。
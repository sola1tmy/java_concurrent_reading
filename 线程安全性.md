# 线程安全性

### 线程安全性
对象在各种情况下数据都正确，线程安全
无状态对象是线程安全的

### 原子性
当线程A完全执行完才执行B，那么AB彼此来说是原子的
- 竞态条件：不恰当的调用时序导致的不正确结果
- 延迟初始化：参考单例的一些写法导致的多次实例化
- 复合操作：无状态的类添加一个状态时，如果它完全给线程安全的对象管理，那么这个类仍然是线程安全的

### 加锁机制
- 内置锁:syncronized
- 重入锁: 内置锁是可重入的

### 用锁来保护状态
- 同时被多个线程访问的可变状态变量，访问时持有同一个锁，那么这个状态变量是由这个锁保护的
- 每个共享和可变的变量都应该只由一个锁来保护
- 只有被多个线程访问的数据需要锁的保护
- 同一个对象的多个同步操作可能存在竞态条件（Page23）

### 活跃性与性能
- 内置锁不一定要作用于整个方法在必要的地方加锁可以对活跃性性能有帮助

### 注意
- volatile可以保证可见性，但是保证不了原子性，atomc能保证原子性
比如++操作，可能在值写入之前，被其他线程就看到了结果，导致数据不正确

- 线程安全定义中要求，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变形条件不被破坏（书本19页）

- 状态相关的变量要在同一个原子操作中执行

- **内置锁是可重入**的！！！！同一个线程可以直接获取到锁

- synchronized修饰方法锁住的是对象的本身，也是this